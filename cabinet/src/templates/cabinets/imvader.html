<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Space Imvaders</title>
    <script
            src="https://cdn.signalfx.com/o11y-gdi-rum/v0.19.1/splunk-otel-web.js"
            crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
      if (typeof window.soundVolume === "undefined") {
        window.soundVolume = 0.1;
      }

      function updateGameMetadata(data) {
        const metadataElement = document.getElementById("game-metadata");

        if (!metadataElement) {
          console.error("Metadata element not found");
          return;
        }

        metadataElement.innerHTML = "";

        Object.entries(data).forEach(([key, value]) => {
          const item = document.createElement("span");
          item.className = "mr-4";
          item.innerHTML = `<strong>${key}:</strong> ${value}`;
          metadataElement.appendChild(item);
        });
      }

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game state
      let intervalID;
      let score = 0;
      let lives = 3;
      let level = 1;
      let gameOver = false;
      let levelUpPause = false;
      let enemyDirection = 1;
      let enemyDropDistance = 30;
      let enemySpeed = 1;
      let version = Math.floor(Math.random() * 2) + 0.75;
      let username = "player"+Math.floor(Math.random() * 100)
      let gameDuration = 0;

      updateGameMetadata({
        Score: score,
        Lives: lives,
        Level: level,
      })

      // TODO! :)
      // SplunkRum.init({
      //   realm: "us1",
      //   rumAccessToken: "FOO",
      //   applicationName: "imvaders",
      //   version: version,
      //   deploymentEnvironment: "gamify",
      // });

      // Player
      const player = {
        x: 375,
        y: 530,
        width: 50,
        height: 50,
        speed: 5,
      };

      // Player ship SVG
      const playerShipSVG = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50" height="50">
            <path fill="#4a90e2" d="M25,2 L10,48 L25,38 L40,48 Z" />
            <circle fill="#e74c3c" cx="25" cy="20" r="6" />
        </svg>
        `;

      // Alien ship SVGs
      const alienShipSVGs = [
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50" height="50">
                <ellipse fill="#8e44ad" cx="25" cy="25" rx="20" ry="10" />
                <circle fill="#2ecc71" cx="25" cy="25" r="5" />
                <rect fill="#8e44ad" x="5" y="20" width="40" height="10" />
            </svg>`,
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50" height="50">
                <path fill="#e67e22" d="M10,25 Q25,5 40,25 Q25,45 10,25 Z" />
                <circle fill="#3498db" cx="25" cy="25" r="5" />
            </svg>`,
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50" height="50">
                <rect fill="#c0392b" x="10" y="20" width="30" height="20" rx="10" ry="10" />
                <circle fill="#f1c40f" cx="20" cy="30" r="3" />
                <circle fill="#f1c40f" cx="30" cy="30" r="3" />
            </svg>`,
      ];

      // Convert SVGs to images
      function svgToImage(svgString) {
        const img = new Image();
        const svg = new Blob([svgString], { type: "image/svg+xml" });
        const url = URL.createObjectURL(svg);
        img.src = url;
        return img;
      }

      const playerShipImg = svgToImage(playerShipSVG);
      const alienShipImgs = alienShipSVGs.map(svgToImage);

      // Enemies
      const enemies = [];
      const enemyRows = 5;
      const enemyCols = 10;
      const enemyWidth = 40;
      const enemyHeight = 40;
      const enemyPadding = 10;

      // Bullets
      const bullets = [];
      const enemyBullets = [];
      const bulletWidth = 3;
      const bulletHeight = 10;
      const bulletSpeed = 7;

      // Sounds
      const shootSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/677/677-preview.mp3"
      );
      const explosionSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/235/235-preview.mp3"
      );
      const playerHitSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/1014/1014-preview.mp3"
      );
      const levelUpSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/220/220-preview.mp3"
      );

      shootSound.volume = window.soundVolume;
      explosionSound.volume = window.soundVolume;
      playerHitSound.volume = window.soundVolume;
      levelUpSound.volume = window.soundVolume;

      window.addEventListener("volumeChange", (e) => {
        shootSound.volume = e.detail.volume;
        explosionSound.volume = e.detail.volume;
        playerHitSound.volume = e.detail.volume;
        levelUpSound.volume = e.detail.volume;
      });

      function postState() {
        if(!gameOver) gameDuration+=2;
        dict = {
          game_session_id: "{{ gamesession }}",
          title: "imvaders",
          player_name: "{{ user_username }}",
          player_id: "{{ user_uuid }}",
          active: !gameOver,
          level: level,
          lives_remaining: lives,
          current_score: score,
          position: [player.x, player.y],
          projectiles: bullets.length,
          duration: gameDuration,
          version: version,
        };

        $.ajax({
          type: "POST",
          url: '{{ url_for("routes.record_game_score") }}',
          data: JSON.stringify(dict),
          contentType: "application/json",
        });
      }

      // Initialize enemies
      function initEnemies() {
        enemies.length = 0;
        for (let row = 0; row < enemyRows; row++) {
          for (let col = 0; col < enemyCols; col++) {
            enemies.push({
              x: col * (enemyWidth + enemyPadding) + 50,
              y: row * (enemyHeight + enemyPadding) + 50,
              width: enemyWidth,
              height: enemyHeight,
              type: Math.floor(Math.random() * alienShipImgs.length),
            });
          }
        }
      }

      unlockQuizQuestion();
      initEnemies();

      // Stars
      const stars = [];
      const numStars = 100;

      // Update and draw stars
      function updateStars() {
        ctx.fillStyle = "white";
        stars.forEach((star) => {
          star.y += star.speed;
          if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
          }
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function moveEnemies() {
        let shouldChangeDirection = false;
        enemies.forEach((enemy) => {
          enemy.x += enemySpeed * enemyDirection;
          if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
            shouldChangeDirection = true;
          }
        });

        if (shouldChangeDirection) {
          enemyDirection *= -1;
          enemies.forEach((enemy) => {
            enemy.y += enemyDropDistance;
          });
        }
      }

      function shoot() {
        bullets.push({
          x: player.x + player.width / 2 - bulletWidth / 2,
          y: player.y,
          width: bulletWidth,
          height: bulletHeight,
        });
        shootSound.currentTime = 0;
        shootSound.play();
      }

      function enemyShoot() {
        if (enemies.length > 0 && Math.random() < 0.02) {
          const shootingEnemy =
            enemies[Math.floor(Math.random() * enemies.length)];
          enemyBullets.push({
            x: shootingEnemy.x + shootingEnemy.width / 2 - bulletWidth / 2,
            y: shootingEnemy.y + shootingEnemy.height,
            width: bulletWidth,
            height: bulletHeight,
          });
        }
      }

      function updateBullets() {
        // Player bullets
        bullets.forEach((bullet, index) => {
          bullet.y -= bulletSpeed;
          if (bullet.y < 0) {
            bullets.splice(index, 1);
          }

          enemies.forEach((enemy, enemyIndex) => {
            if (
              bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y
            ) {
              enemies.splice(enemyIndex, 1);
              bullets.splice(index, 1);
              score += 10;
              explosionSound.currentTime = 0;
              explosionSound.play();

              updateGameMetadata({
                Score: score,
                Lives: lives,
                Level: level,
              })

              if (enemies.length === 0) {
                levelUp();
              }
            }
          });
        });

        // Enemy bullets
        enemyBullets.forEach((bullet, index) => {
          bullet.y += bulletSpeed;
          if (bullet.y > canvas.height) {
            enemyBullets.splice(index, 1);
          }

          if (
            bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y
          ) {
            enemyBullets.splice(index, 1);
            lives--;
            playerHitSound.currentTime = 0;
            playerHitSound.play();

            updateGameMetadata({
              Score: score,
              Lives: lives,
              Level: level,
            })

            if (lives <= 0) {
              gameOver = true;
              postState();
            }
          }
        });
      }

      function drawBullets() {
        ctx.fillStyle = "white";
        bullets.forEach((bullet) => {
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        ctx.fillStyle = "red";
        enemyBullets.forEach((bullet) => {
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });
      }

      function levelUp() {
        level++;
        enemySpeed += 0.5;
        initEnemies();
        levelUpSound.currentTime = 0;
        levelUpSound.play();
        levelUpPause = true;
        unlockQuizQuestion();
      }

      function gameLoop() {
        if (gameOver) {
          clearInterval(intervalID);
          intervalID = null;
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          updateStars();
          ctx.fillStyle = "white";
          ctx.font = "48px Arial";
          ctx.textAlign = "center";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px Arial";
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2,
            canvas.height / 2 + 50
          );
          ctx.fillText(
            "Press R to Restart",
            canvas.width / 2,
            canvas.height / 2 + 100
          );

          if (keys["KeyR"]) {
            restartGame();
          }
          requestAnimationFrame(gameLoop);
          return;
        } else if (levelUpPause) {
          ctx.fillStyle = "white";
          ctx.font = "48px Arial";
          ctx.textAlign = "center";
          ctx.fillText("NEXT LEVEL?", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px Arial";
          ctx.fillText(
                  `Final Score: ${score}`,
                  canvas.width / 2,
                  canvas.height / 2 + 50
          );

          const text = "Press C to Continue\nBut first, answer a quiz question!";
          const lines = text.split("\n");
          lines.forEach((line, i) => {
            ctx.fillText(line, canvas.width / 2, canvas.height / 2 + 100 + i * 20);
          });

          if (keys["KeyC"]) {
            levelUpPause = false;
          }
          requestAnimationFrame(gameLoop);
          return;
        }

        if (!intervalID) {
          intervalID = setInterval(postState, 2000);
        }

        // Clear the canvas
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Update and draw stars
        updateStars();

        // Move player
        if (keys["ArrowLeft"] && player.x > 0) {
          player.x -= player.speed;
        }
        if (keys["ArrowRight"] && player.x < canvas.width - player.width) {
          player.x += player.speed;
        }

        // Draw player ship
        ctx.drawImage(
          playerShipImg,
          player.x,
          player.y,
          player.width,
          player.height
        );

        // Move and draw enemies
        moveEnemies();
        enemies.forEach((enemy) => {
          ctx.drawImage(
            alienShipImgs[enemy.type],
            enemy.x,
            enemy.y,
            enemy.width,
            enemy.height
          );

          // Check for game over conditions
          if (enemy.y + enemy.height >= player.y) {
            gameOver = true;
            postState();
          }
        });

        // Enemy shooting
        enemyShoot();

        // Update and draw bullets
        updateBullets();
        drawBullets();

        requestAnimationFrame(gameLoop);
      }

      function restartGame() {
        score = 0;
        lives = 3;
        level = 1;
        gameOver = false;
        gameDuration = 0;
        enemyDirection = 1;
        enemySpeed = 1;
        player.x = 375;
        player.y = 530;
        bullets.length = 0;
        enemyBullets.length = 0;
        initEnemies();
      }

      // Key states
      const keys = {};

      // Event listeners
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (e.code === "Space") {
          if (version < 1) {
            //BUG:
            shoot();
            return;
          }
          if (bullets.length < 1) {
            shoot();
          }
        }
      });
      document.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // Start the game loop when all images are loaded
      Promise.all([
        playerShipImg.decode(),
        ...alienShipImgs.map((img) => img.decode()),
      ])
        .then(() => {
          gameLoop();
        })
        .catch((err) => {
          console.error("Error loading images:", err);
        });
    </script>
  </body>
</html>

