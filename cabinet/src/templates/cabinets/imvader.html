<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Space Imvaders</title>
    <script
      src="https://cdn.signalfx.com/o11y-gdi-rum/v0.19.1/splunk-otel-web.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
      if (typeof window.soundVolume === "undefined") {
        window.soundVolume = 0;
      }

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game state
      let intervalID;
      let score = 0;
      let lives = 3;
      let level = 1;
      let gameOver = false;
      let levelUpPause = false;
      let enemyDirection = 1;
      let enemyDropDistance = 30;
      let enemySpeed = 1;
      let version = 0.75;
      let username = "player" + Math.floor(Math.random() * 100);
      let gameDuration = 0;
      let isDeathAnimating = false;
      let deathAnimationFrame = 0;
      const DEATH_ANIMATION_DURATION = 60; // frames
      const DEATH_PAUSE_DURATION = 30; // frames

      // Add to game state section
      const barriers = [];
      const BARRIER_COUNT = 4;
      const BARRIER_WIDTH = 60;
      const BARRIER_HEIGHT = 40;
      const BARRIER_RESOLUTION = 2; // Size of destructible pixels
      const BARRIER_Y = 450; // Vertical position of barriers

      function getVersion() {
        $.ajax({
          type: "GET",
          url: '{{ url_for("routes.get_imvaders_version") }}',
          success: function (response) {
            version = response.version;
          },
          error: function (error) {
            console.log("Error determining imvaders version:", error);
          },
        });
      }

      getVersion();

      drawScore({
        Score: score,
        Lives: lives,
        Level: level,
      });

      // TODO! :)
      // SplunkRum.init({
      //   realm: "us1",
      //   rumAccessToken: "FOO",
      //   applicationName: "imvaders",
      //   version: version,
      //   deploymentEnvironment: "gamify",
      // });

      // Player
      const player = {
        x: 375,
        y: 530,
        width: 50,
        height: 50,
        speed: 5,
      };

      const alienShipURIs = [
        "{{ url_for('static', filename='imvaders/a1.png') }}",
        "{{ url_for('static', filename='imvaders/a2.png') }}",
        "{{ url_for('static', filename='imvaders/a3.png') }}",
      ];

      // Convert SVGs to images
      function svgToImage(svgString) {
        const img = new Image();
        const svg = new Blob([svgString], { type: "image/svg+xml" });
        const url = URL.createObjectURL(svg);
        img.src = url;
        return img;
      }

      function urlToImage(src) {
        const img = new Image();
        img.src = src;
        return img;
      }

      const playerShipImg = urlToImage(
        "{{ url_for('static', filename='imvaders/ship.png') }}"
      );
      const alienShipImgs = alienShipURIs.map(urlToImage);

      // Enemies
      const enemies = [];
      const enemyRows = 5;
      const enemyCols = 10;
      const enemyWidth = 40;
      const enemyHeight = 40;
      const enemyPadding = 10;

      // Bullets
      const bullets = [];
      const enemyBullets = [];
      const bulletWidth = 3;
      const bulletHeight = 10;
      const bulletSpeed = 7;

      // Sounds
      const shootSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/677/677-preview.mp3"
      );
      const explosionSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/235/235-preview.mp3"
      );
      const playerHitSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/1014/1014-preview.mp3"
      );
      const levelUpSound = new Audio(
        "https://assets.mixkit.co/active_storage/sfx/220/220-preview.mp3"
      );

      shootSound.volume = 0;
      explosionSound.volume = 0;
      playerHitSound.volume = 0;
      levelUpSound.volume = 0;

      function postState() {
        if (!gameOver) gameDuration += 2;
        dict = {
          game_session_id: "{{ gamesession }}",
          title: "imvaders",
          player_name: "{{ user_username }}",
          player_id: "{{ user_uuid }}",
          active: !gameOver,
          level: level,
          lives_remaining: lives,
          current_score: score,
          position: [player.x, player.y],
          projectiles: bullets.length,
          duration: gameDuration,
          version: version,
        };

        $.ajax({
          type: "POST",
          url: '{{ url_for("routes.record_game_score") }}',
          data: JSON.stringify(dict),
          contentType: "application/json",
        });
      }

      // Initialize enemies
      function initEnemies() {
        enemies.length = 0;
        for (let row = 0; row < enemyRows; row++) {
          for (let col = 0; col < enemyCols; col++) {
            enemies.push({
              x: col * (enemyWidth + enemyPadding) + 50,
              y: row * (enemyHeight + enemyPadding) + 50,
              width: enemyWidth,
              height: enemyHeight,
              type: Math.floor(Math.random() * alienShipImgs.length),
            });
          }
        }
      }

      initEnemies();

      // Initialize barriers
      function initBarriers() {
        barriers.length = 0;
        const spacing = canvas.width / (BARRIER_COUNT + 1);

        for (let i = 0; i < BARRIER_COUNT; i++) {
          const barrier = {
            x: spacing * (i + 1) - BARRIER_WIDTH / 2,
            y: BARRIER_Y,
            width: BARRIER_WIDTH,
            height: BARRIER_HEIGHT,
            pixels: new Array(Math.ceil(BARRIER_WIDTH / BARRIER_RESOLUTION))
              .fill()
              .map(() =>
                new Array(Math.ceil(BARRIER_HEIGHT / BARRIER_RESOLUTION)).fill(
                  1
                )
              ),
          };
          barriers.push(barrier);
        }
      }

      initBarriers();

      function drawBarriers() {
        barriers.forEach((barrier) => {
          // Draw glow effect
          ctx.shadowBlur = 25;
          ctx.shadowColor = "#00ff00";
          ctx.fillStyle = "#00ff00";

          // Draw each pixel with glow
          for (let x = 0; x < barrier.pixels.length; x++) {
            for (let y = 0; y < barrier.pixels[x].length; y++) {
              if (barrier.pixels[x][y]) {
                ctx.fillRect(
                  barrier.x + x * BARRIER_RESOLUTION,
                  barrier.y + y * BARRIER_RESOLUTION,
                  BARRIER_RESOLUTION,
                  BARRIER_RESOLUTION
                );
              }
            }
          }

          // Reset shadow for other game elements
          ctx.shadowBlur = 0;
        });
      }

      // Add damage to barrier at specific coordinates
      function damageBarrier(barrier, hitX, hitY, radius = 2) {
        const barrierX = Math.floor((hitX - barrier.x) / BARRIER_RESOLUTION);
        const barrierY = Math.floor((hitY - barrier.y) / BARRIER_RESOLUTION);

        // Create circular damage pattern
        for (let x = -radius; x <= radius; x++) {
          for (let y = -radius; y <= radius; y++) {
            if (x * x + y * y <= radius * radius) {
              const pixelX = barrierX + x;
              const pixelY = barrierY + y;

              if (
                pixelX >= 0 &&
                pixelX < barrier.pixels.length &&
                pixelY >= 0 &&
                pixelY < barrier.pixels[0].length
              ) {
                barrier.pixels[pixelX][pixelY] = 0;
              }
            }
          }
        }
      }

      // Check collision between point and barrier
      function checkBarrierCollision(x, y) {
        for (let barrier of barriers) {
          if (
            x >= barrier.x &&
            x < barrier.x + barrier.width &&
            y >= barrier.y &&
            y < barrier.y + barrier.height
          ) {
            const barrierX = Math.floor((x - barrier.x) / BARRIER_RESOLUTION);
            const barrierY = Math.floor((y - barrier.y) / BARRIER_RESOLUTION);

            if (
              barrierX >= 0 &&
              barrierX < barrier.pixels.length &&
              barrierY >= 0 &&
              barrierY < barrier.pixels[0].length &&
              barrier.pixels[barrierX][barrierY]
            ) {
              damageBarrier(barrier, x, y);
              return true;
            }
          }
        }
        return false;
      }

      function checkEnemyBarrierCollisions() {
        enemies.forEach((enemy) => {
          barriers.forEach((barrier) => {
            if (
              enemy.y + enemy.height >= barrier.y &&
              enemy.x < barrier.x + barrier.width &&
              enemy.x + enemy.width > barrier.x
            ) {
              // Create multiple damage points across the enemy width
              const damagePoints = 5;
              for (let i = 0; i < damagePoints; i++) {
                const damageX =
                  enemy.x + enemy.width * (i / (damagePoints - 1));
                damageBarrier(barrier, damageX, barrier.y, 3); // Larger damage radius
              }

              // Play explosion sound for dramatic effect
              //explosionSound.currentTime = 0;
              //explosionSound.play();
            }
          });
        });
      }

      // Stars
      const stars = [];
      const numStars = 100;

      // Update and draw stars
      function updateStars() {
        ctx.fillStyle = "white";
        stars.forEach((star) => {
          star.y += star.speed;
          if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
          }
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function moveEnemies() {
        let shouldChangeDirection = false;
        enemies.forEach((enemy) => {
          enemy.x += enemySpeed * enemyDirection;
          if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
            shouldChangeDirection = true;
          }
        });

        if (shouldChangeDirection) {
          enemyDirection *= -1;
          enemies.forEach((enemy) => {
            enemy.y += enemyDropDistance;
          });
        }
      }

      function shoot() {
        bullets.push({
          x: player.x + player.width / 2 - bulletWidth / 2,
          y: player.y,
          width: bulletWidth,
          height: bulletHeight,
        });
        shootSound.currentTime = 0;
        shootSound.play();
      }

      function enemyShoot() {
        if (enemies.length > 0 && Math.random() < 0.02) {
          const shootingEnemy =
            enemies[Math.floor(Math.random() * enemies.length)];
          enemyBullets.push({
            x: shootingEnemy.x + shootingEnemy.width / 2 - bulletWidth / 2,
            y: shootingEnemy.y + shootingEnemy.height,
            width: bulletWidth,
            height: bulletHeight,
          });
        }
      }

      function updateBullets() {
        // Player bullets
        bullets.forEach((bullet, index) => {
          bullet.y -= bulletSpeed;
          if (bullet.y < 0) {
            bullets.splice(index, 1);
          }

          // Check barrier collision first
          if (checkBarrierCollision(bullet.x + bullet.width / 2, bullet.y)) {
            bullets.splice(index, 1);
            return;
          }

          enemies.forEach((enemy, enemyIndex) => {
            if (
              bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y
            ) {
              enemies.splice(enemyIndex, 1);
              bullets.splice(index, 1);
              score += 10;
              explosionSound.currentTime = 0;
              explosionSound.play();

              drawScore({
                Score: score,
                Lives: lives,
                Level: level,
              });

              if (enemies.length === 0) {
                levelUp();
              }
            }
          });
        });

        // Enemy bullets
        enemyBullets.forEach((bullet, index) => {
          bullet.y += bulletSpeed;
          if (bullet.y > canvas.height) {
            enemyBullets.splice(index, 1);
          }

          // Check barrier collision first
          if (
            checkBarrierCollision(
              bullet.x + bullet.width / 2,
              bullet.y + bullet.height
            )
          ) {
            enemyBullets.splice(index, 1);
            return;
          }

          if (
            bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y &&
            !isDeathAnimating
          ) {
            enemyBullets.splice(index, 1);
            lives--;
            playerHitSound.currentTime = 0;
            playerHitSound.play();

            if (lives > 0) {
              isDeathAnimating = true;
              deathAnimationFrame = 0;
            }

            drawScore({
              Score: score,
              Lives: lives,
              Level: level,
            });

            if (lives <= 0) {
              gameOver = true;
              // unlock a question so they can advance to not slow version w/out having to win
              unlockQuizQuestion();
              postState();
            }
          }
        });
      }

      function drawScore(data) {
        const text = `score: ${data.Score} | lives: ${data.Lives} | level: ${data.Level}`;
        const startX = canvas.width / 2;
        const startY = 15;
        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(text, startX, startY);
      }

      function drawBullets() {
        // Player bullets with blue glow
        bullets.forEach((bullet) => {
          const gradient = ctx.createRadialGradient(
            bullet.x + bullet.width / 2,
            bullet.y + bullet.height / 2,
            0,
            bullet.x + bullet.width / 2,
            bullet.y + bullet.height / 2,
            10
          );
          gradient.addColorStop(0, "rgba(255, 255, 255, 1)"); // White center
          gradient.addColorStop(0.4, "rgba(0, 196, 255, 0.5)"); // Blue glow
          gradient.addColorStop(1, "rgba(0, 196, 255, 0)"); // Fade out

          ctx.fillStyle = gradient;
          ctx.fillRect(
            bullet.x - 8,
            bullet.y - 8,
            bullet.width + 16,
            bullet.height + 16
          );
          ctx.fillStyle = "white"; // Core of the bullet
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });

        // Enemy bullets with red glow
        enemyBullets.forEach((bullet) => {
          const gradient = ctx.createRadialGradient(
            bullet.x + bullet.width / 2,
            bullet.y + bullet.height / 2,
            0,
            bullet.x + bullet.width / 2,
            bullet.y + bullet.height / 2,
            10
          );
          gradient.addColorStop(0, "rgba(255, 255, 255, 1)"); // White center
          gradient.addColorStop(0.4, "rgba(255, 0, 0, 0.5)"); // Red glow
          gradient.addColorStop(1, "rgba(255, 0, 0, 0)"); // Fade out

          ctx.fillStyle = gradient;
          ctx.fillRect(
            bullet.x - 8,
            bullet.y - 8,
            bullet.width + 16,
            bullet.height + 16
          );
          ctx.fillStyle = "red"; // Core of the bullet
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });
      }

      function createGlitchEffect(imageData, intensity) {
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;

        // Create random glitch slices
        for (let i = 0; i < intensity; i++) {
          const y = Math.random() * height;
          const sliceHeight = Math.random() * 20 + 2;
          const offset = Math.random() * 20 - 10;

          // Shift a slice of pixels
          for (let j = y; j < y + sliceHeight && j < height; j++) {
            for (let k = 0; k < width; k++) {
              const sourceIdx = (Math.floor(j) * width + k) * 4;
              const targetIdx =
                (Math.floor(j) * width + Math.floor(k + offset)) * 4;

              if (targetIdx >= 0 && targetIdx < data.length - 3) {
                for (let l = 0; l < 4; l++) {
                  data[targetIdx + l] = data[sourceIdx + l];
                }
              }
            }
          }
        }

        // Add color channel shifting
        for (let i = 0; i < data.length; i += 4) {
          if (Math.random() < 0.1) {
            data[i] = Math.min(255, data[i] + Math.random() * 100); // R
            data[i + 2] = Math.max(0, data[i + 2] - Math.random() * 50); // B
          }
        }
      }

      function levelUp() {
        level++;
        enemySpeed += 0.5;
        initEnemies();
        levelUpSound.currentTime = 0;
        levelUpSound.play();
        levelUpPause = true;
        unlockQuizQuestion();
      }

      let isMuted = true;

      // Define button position and size
      const muteButtonWidth = 75;
      const muteButtonHeight = 30;
      const muteButtonX = 10;
      const muteButtonY = canvas.height - 40;

      function drawMuteButton() {
        ctx.clearRect(
          muteButtonX,
          muteButtonY,
          muteButtonWidth,
          muteButtonHeight
        );

        ctx.fillStyle = "#333";
        ctx.fillRect(
          muteButtonX,
          muteButtonY,
          muteButtonWidth,
          muteButtonHeight
        );

        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const buttonText = isMuted ? "unmute (m)" : "mute (m)";
        ctx.fillText(
          buttonText,
          muteButtonX + muteButtonWidth / 2,
          muteButtonY + muteButtonHeight / 2
        );
      }

      function muteOrUnmute() {
        isMuted = !isMuted;

        let setVolume = 0;
        if (!isMuted) {
          setVolume = 0.1;
        }

        shootSound.volume = setVolume;
        explosionSound.volume = setVolume;
        playerHitSound.volume = setVolume;
        levelUpSound.volume = setVolume;
      }

      drawMuteButton();

      function gameLoop() {
        if (gameOver) {
          clearInterval(intervalID);
          intervalID = null;
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          updateStars();
          ctx.fillStyle = "white";
          ctx.font = "48px Arial";
          ctx.textAlign = "center";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px Arial";
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2,
            canvas.height / 2 + 50
          );

          const text = "Press R to Restart\nBut first, answer a quiz question!";
          const lines = text.split("\n");
          lines.forEach((line, i) => {
            ctx.fillText(
              line,
              canvas.width / 2,
              canvas.height / 2 + 100 + i * 20
            );
          });

          if (keys["KeyR"]) {
            restartGame();
          }
          requestAnimationFrame(gameLoop);
          return;
        } else if (levelUpPause) {
          ctx.fillStyle = "white";
          ctx.font = "48px Arial";
          ctx.textAlign = "center";
          ctx.fillText("NEXT LEVEL?", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px Arial";
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2,
            canvas.height / 2 + 50
          );

          const text =
            "Press C to Continue\nBut first, answer a quiz question!";
          const lines = text.split("\n");
          lines.forEach((line, i) => {
            ctx.fillText(
              line,
              canvas.width / 2,
              canvas.height / 2 + 100 + i * 20
            );
          });

          if (keys["KeyC"]) {
            levelUpPause = false;
          }
          requestAnimationFrame(gameLoop);
          return;
        }

        if (!intervalID) {
          intervalID = setInterval(postState, 2000);
        }

        // Clear the canvas
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawMuteButton();
        drawScore({
          Score: score,
          Lives: lives,
          Level: level,
        });

        // Update and draw stars
        updateStars();

        // Move player
        if (keys["ArrowLeft"] && player.x > 0) {
          player.x -= player.speed;
        }
        if (keys["ArrowRight"] && player.x < canvas.width - player.width) {
          player.x += player.speed;
        }

        if (isDeathAnimating) {
          deathAnimationFrame++;

          // Create an offscreen canvas for the glitch effect
          const offscreen = document.createElement("canvas");
          offscreen.width = player.width;
          offscreen.height = player.height;
          const offCtx = offscreen.getContext("2d");

          // Draw the player ship to the offscreen canvas
          offCtx.drawImage(playerShipImg, 0, 0, player.width, player.height);

          // Apply glitch effect
          const imageData = offCtx.getImageData(
            0,
            0,
            player.width,
            player.height
          );
          const intensity = Math.min(20, deathAnimationFrame / 2);
          createGlitchEffect(imageData, intensity);
          offCtx.putImageData(imageData, 0, 0);

          // Draw the glitched ship to the main canvas
          ctx.drawImage(
            offscreen,
            player.x,
            player.y,
            player.width,
            player.height
          );

          // End animation after duration
          if (deathAnimationFrame >= DEATH_ANIMATION_DURATION) {
            isDeathAnimating = false;
            deathAnimationFrame = 0;
          }

          // Pause other game actions during animation
          requestAnimationFrame(gameLoop);
          return;
        }

        // Draw player ship
        ctx.drawImage(
          playerShipImg,
          player.x,
          player.y,
          player.width,
          player.height
        );

        // Move and draw enemies
        moveEnemies();
        enemies.forEach((enemy) => {
          ctx.drawImage(
            alienShipImgs[enemy.type],
            enemy.x,
            enemy.y,
            enemy.width,
            enemy.height
          );

          // Check for game over conditions
          if (enemy.y + enemy.height >= player.y) {
            gameOver = true;

            // unlock a question so they can advance to not slow version w/out having to win
            unlockQuizQuestion();
            postState();
          }
        });

        checkEnemyBarrierCollisions();

        // Enemy shooting
        enemyShoot();

        drawBarriers();
        updateBullets();
        drawBullets();

        requestAnimationFrame(gameLoop);
      }

      function restartGame() {
        score = 0;
        lives = 3;
        level = 1;
        gameOver = false;
        gameDuration = 0;
        enemyDirection = 1;
        enemySpeed = 1;
        player.x = 375;
        player.y = 530;
        bullets.length = 0;
        enemyBullets.length = 0;
        initEnemies();
        initBarriers();
        getVersion();
      }

      // Key states
      const keys = {};

      // Event listeners
      document.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (e.code === "Space") {
          if (version < 1) {
            // when on version <1 we only allow shooting one bullet at a time! :)
            if (bullets.length < 1) {
              shoot();
            }
          } else {
            shoot();
          }
        } else if (e.code === "KeyM") {
          muteOrUnmute();
          drawMuteButton();
        }
      });
      document.addEventListener("keyup", (e) => {
        keys[e.code] = false;
      });

      // Start the game loop when all images are loaded
      Promise.all([
        playerShipImg.decode(),
        ...alienShipImgs.map((img) => img.decode()),
      ])
        .then(() => {
          gameLoop();
        })
        .catch((err) => {
          console.error("Error loading images:", err);
        });
    </script>
  </body>
</html>
